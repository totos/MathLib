{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf410
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
\f3\fswiss\fcharset77 Helvetica-Oblique;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red0\green115\blue0;
\red191\green0\blue0;\red0\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;\red0\green115\blue0;
}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 MarkovSet				
\fs28 first order markov set
\f1\b0\fs24 \
\
\
\
instance creation:\
\
\

\f0\b 	*new(args, updateSeeds)
\f1\b0 \
		
\f0\b args
\f1\b0 \
			a list of arrays that each represent \
			one node in the set:\
			
\f0\b [element, [next_elements], [weigths]]
\f1\b0 \
			\
			
\f0\b next_elements
\f1\b0 \
				the next node is searched by simple equality.\
				if nil, this is a terminator node\
			
\f0\b weights
\f1\b0 \
				the array is normalized.\
				if weigths is nil, equal weight is used\
			\
			if args is nil, the set is created and may be trained by the \
			other methods.\
		\
		
\f0\b updateSeeds\
			
\f1\b0 if set to true, each element is always added to the seeds.\
\
\

\f0\b 	*fill(n, stream) 
\f1\b0 	\
		
\f0\b n
\f1\b0 			number of items to read\
		
\f0\b stream
\f1\b0 		a function or stream that returns items to read\
		
\f2\fs18 \
			\

\f1\fs24 \
instance methods\ul \

\f0\b \ulnone \
		read(prev, next)\
			
\f1\b0 read a pair of values
\f0\b \
		\
		put(element, next_elements, weights)\
			
\f1\b0 insert a node. any old node is overwritten\
		\
		
\f0\b remove(prev, next)
\f1\b0 \
			remove a pair of values\
			\
		
\f0\b next(for)
\f1\b0 \
			return a next item for the arg value.\
			if arg is nil, choose from seeds.\
		\
		
\f0\b parse(stream, length)
\f1\b0 \
			read 
\f3\i length
\f1\i0  items into the set from the stream\
			\

\f2\fs18 \ul 		
\f0\b\fs24 \ulnone asStream
\f2\b0\fs18 \
			
\f1\fs24 returns a stream that creates a markov chain\
		\
		
\f0\b spy
\f1\b0 \
			decrepated: use Pspy (see examples)\
			\
			
\f2\fs18 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // examples:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 // direct node definition\cf0 \
(\
m = \cf3 MarkovSet\cf0 ([\
			[100, [120, 130]],\
			[120, [100, 1900]],\
			[130, \cf3 nil\cf0 ],\
		]);\
)\
\
8.do \{ m.next(100).postln \};\
8.do \{ m.next(120).postln \};\
8.do \{ m.next(130).postln \};\
\
\cf2 // training by a stream\cf0 \
\
m = \cf3 MarkovSet\cf0 .fill(100, \cf3 Pseq\cf0 ([1, 2, 3, 4, \cf3 Prand\cf0 ([5, 55, 555])], \cf3 inf\cf0 ).asStream);\
8.do \{ m.next(1).postln \};\
8.do \{ m.next(4).postln \};\
8.do \{ m.next(55).postln \};\
\
\cf2 // training bit by bit\cf0 \
\
m = \cf3 MarkovSet\cf0 .new;\
m.read(\cf4 \\x\cf0 , \cf4 \\y\cf0 );\
m.read(\cf4 \\x\cf0 , \cf4 \\z\cf0 );\
m.read(\cf4 \\z\cf0 , \cf4 \\abcde\cf0 );\
m.read(\cf4 \\y\cf0 , \cf3 nil\cf0 );\
\
8.do \{ m.next(\cf4 \\x\cf0 ).postln \};\
8.do \{ m.next(\cf4 \\y\cf0 ).postln \};\
8.do \{ m.next(\cf4 \\z\cf0 ).postln \};\
\
m.read(\cf4 \\y\cf0 , \cf4 \\mmmm\cf0 );\
8.do \{ m.next(\cf4 \\y\cf0 ).postln \}; \cf2 // now it sometimes terminates\cf0 \
\
m.remove(\cf4 \\y\cf0 , \cf4 \\mmmm\cf0 );\
8.do \{ m.next(\cf4 \\y\cf0 ).postln \};\
\
\
\cf2 //////////  creating streams\cf0 \
\
(\
m = \cf3 MarkovSet\cf0 ([\
			[100, [120, 130]],\
			[120, [100, 1900]],\
			[130, \cf3 [100]\cf0 ],\
			[1900, \cf3 [1000, 2000, 3000]\cf0 ],\
		]);\
)\
\
m.makeSeeds;\
x = m.asStream;\
32.do \{ x.next.postln \};\
\
\
\cf2 // spy out a stream to feed it in\cf0 \
\
z = \cf3 Pseq\cf0 ([100, 200, 300, \cf3 Prand\cf0 ([1.2, 1.4, 1.5])],\cf3 inf\cf0 ).asStream;\
z = \cf3 Pspy\cf0 (m, z).asStream;\
\
32.do \{ x.next.postln \};\
15.do \{ z.next \} \cf2 // add some more elements from z\cf0 \
32.do \{ x.next.postln \};\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf5 // event streams\cf6 \
(\
\cf7 SynthDef\cf6 (\cf8 "mark"\cf6 , \{ \cf7 arg\cf6  out, freq, sustain=1, amp=0.1, pan;\
	\cf7 var\cf6  env, u=1;\
	env = \cf7 EnvGen\cf6 .kr(\cf7 Env\cf6 .perc(0.03, sustain, 5), 1, doneAction:2);\
	3.do \{ \cf7 var\cf6  d; d = exprand(0.01, 1); u = \cf7 SinOsc\cf6 .ar(d * 300, u, rrand(0.1, 0.4) * d, 1) \};\
	\cf7 Out\cf6 .ar(out, \cf7 Pan2\cf6 .ar(\cf7 SinOsc\cf6 .ar(u + 1 * freq, 0, amp * env), pan));\
\
\}).store;\
)\
\
(\
a = \cf7 Pbind\cf6 (\
	\cf9 \\freq\cf6 , \cf7 Pshuf\cf6 ([203, 490, 231, 764, 234], \cf7 inf\cf6 ), \
	\cf9 \\dur\cf6 , \cf7 Pshuf\cf6 ([0.5, 0.5, 1.0, 0.25, 0.125, 0.5], \cf7 inf\cf6 )\
);\
m = \cf7 MarkovSet\cf6 .fill(20, \cf7 Pevent\cf6 (a, \cf7 Event\cf6 .default).asStream);\
)\
\
m.dict.keysValuesDo \{ \cf7 |key, val|\cf6  postf(\cf8 "key: %\\t\\tvalue: %\\n"\cf6 , key, val) \}; \cf8 ""\cf6 \
\
\cf5 // compare:\cf6 \
b = \cf7 Pchain\cf6 (\cf7 Pfsm2\cf6 (m), (instrument: \cf9 \\mark\cf6 ));\
c = \cf7 Pchain\cf6 (a, (instrument: \cf9 \\mark\cf6 ));\
\
\cf7 Ppar\cf6 ([b, c]).play;\cf0 \
\
\
\
\
\
}