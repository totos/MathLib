{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf410
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fswiss\fcharset77 Helvetica-Oblique;
\f3\fswiss\fcharset77 Helvetica-BoldOblique;\f4\fnil\fcharset77 Monaco;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red191\green0\blue0;\red96\green96\blue96;
\red0\green0\blue0;\red191\green0\blue0;\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 ShannonFinger				
\fs26 shannon implementation of a markov set\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 superclass: ShannonMarkovSet
\f0\b\fs28 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
The basic 
\f2\i shannon
\f1\i0  implementation of a markov set is to simply leave the data as it is and to\
iterate over it by doing random jumps and looking for the next matching item. The item that\
follows that one is the next item of the chain. As this requires searching the data, which can\
be of very irregular efficiency, this current implementation uses an identity dictionary to find\
the indices of items in constant time. Higher order is slightly more costly, but still this is a major\
speed increase.\
\
This implementation allows to vary the order at each step and it is very fast in reading.\
In difference to 
\f0\b MarkovSet
\f1\b0  and 
\f0\b MarkovSetN
\f1\b0  it can only read data as a chain, not as single nodes. \
Also it does not compress data, as the standard implementation does.\

\f0\b\fs28 \
\

\f2\i\b0\fs24 instance creation:
\f1\i0 \
\
\

\f0\b 	*new(size)\
	*fill(size, stream)\
		\

\f1\b0 \
\

\f2\i instance methods:
\f0\i0\b \
	\
	next(obj, order)\
		
\f1\b0 return the next node for the input obj, using nth order (default = 1)\
		
\f0\b \
	put(index, obj)\
		
\f1\b0 put object in the data at index i\
		
\f0\b \
	wrapPut(index, obj)\
		
\f1\b0 wrapPut object in the data at index i\
		
\f0\b \
	parse(stream, length)\
		
\f1\b0 read 
\f2\i length
\f1\i0  items of stream\
		
\f0\b \
	asStream(order, repeats)\
		
\f1\b0 return a stream that reads from this set.\
		
\f0\b order
\f1\b0  can be any object that returns a stream on .asStream, returning integers.
\f0\b \
\
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\i \cf0 setting the data
\f4\i0\b0\fs18 \
\
m = \cf2 ShannonFinger\cf0 (16); \cf3 // create a new instance with 16 slots.\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 "abc"\cf0 .do \{ \cf2 |item,i|\cf0  m.put(i, item) \}; \cf3 // fill the first 3 slots\cf0 \
\
m.data; \
\
\cf4 "abcdefghij"\cf0 .do \{ \cf2 |item,i|\cf0  m.put(i, item) \}; \cf3 // fill all 10 slots\cf0 \
\
m.data; \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // fill the set directly:\cf0 \
\
m.data = \cf4 "abcdefghij"\cf0 ;\
\
\cf3 // setting higher indices throws an error:\cf0 \
\
m.put(20, $x);\
\
\cf3 // wrapPut:\cf0 \
\
m.wrapPut(20, $x);\
m.data;\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\i\b\fs24 \cf0 using the set with the message 'next'
\f4\i0\b0\fs18 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf5 m.next($b); \cf6 // returns c.\cf5 \
m.next($c); \cf6 // returns d\cf3 \
\
// now put a "c" at index 8:\cf0 \
\
m.put(8, $c);\
m.data;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // generate some output on basis of c:\cf0 \
\
10.do \{ m.next($c).postln \}; \cf3 // returns sometimes j and d\cf0 \
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\i\b\fs24 \cf0 generating a stream:
\f4\i0\b0\fs18 \
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // crete a new, independent stream from m:\cf0 \
x = m.asStream;\
60.do \{ x.next.post; \cf2 Char\cf0 .tab.post \}\
\
\cf3 // whenever there is no next (at the last index), a random index is chosen\cf0 \
\cf3 // to notify of this, set notify to true:\cf0 \
\
m.notify = \cf2 true\cf0 ;\
\
\
\
\cf3 // minimal test:\cf0 \
m.data = (0..20);\
m.next(2);\
m.next(3);\
m.data\
m.lookUp;\
\
\
x = m.asStream;\
60.do \{ x.next.post; \cf2 Char\cf0 .tab.post \}\
\
\cf3 // minimal test:\cf0 \
m.data = \cf4 "abcdefghij"\cf0 ;\
m.next($a);\
m.next($i);\
m.data\
m.lookUp;\
m.put(0, $x);\
\
x = m.asStream;\
60.do \{ x.next.post; \cf2 Char\cf0 .tab.post \}\
\
\
\
\cf3 // with stream\cf0 \
\
m = \cf2 ShannonFinger\cf0 .fill(30, \cf2 Pseq\cf0 ([1, 2, \cf2 Prand\cf0 ([3, 7])],\cf2 inf\cf0 ).asStream);\
m.data\
m.lookUp;\
x = m.asStream;\
60.do \{ x.next.post; \cf2 Char\cf0 .tab.post \}\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 SynthDescLib\cf0 .read;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // listen to the set\cf0 \
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 Pbind\cf0 (\
	\cf7 \\degree\cf0 , \cf2 Pn\cf0 (x),\
	\cf7 \\dur\cf0 , 0.25\
).play;\
)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // change the data slowly\cf0 \
\
m.parse(\cf2 Pseq\cf0 ([1, 2, \cf2 Prand\cf0 ([6, 9], 2)], \cf2 inf\cf0 ), 20);\
m.parse(\cf2 Pseq\cf0 ([1, 5], \cf2 inf\cf0 ), 20);\
m.parse(\cf2 Pseq\cf0 ([5, 0, -2], \cf2 inf\cf0 ), 20);\
m.data = [3, 4, 5, 4, 5, 6];\
m.data\
\
\
\
\
\
}