{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf100
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fswiss\fcharset77 Helvetica-Oblique;
\f3\fswiss\fcharset77 Helvetica-BoldOblique;\f4\fnil\fcharset77 Monaco;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue191;\red191\green0\blue0;
\red96\green96\blue96;\red191\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;\red0\green115\blue0;
}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 ShannonFinger				
\fs26 shannon implementation of a markov set\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 superclass: ShannonMarkovSet
\f0\b\fs28 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
The basic 
\f2\i shannon
\f1\i0  implementation of a markov set is to simply leave the data as it is and to\
iterate over it by doing random jumps and looking for the next matching item. The item that\
follows that one is the next item of the chain. As this requires searching the data, which can\
be of very irregular efficiency, this current implementation uses an identity dictionary to find\
the indices of items in constant time. Higher order is slightly more costly, but still this is a major\
speed increase.\
\
This implementation allows to vary the order at each step and it is very fast in reading.\
In difference to 
\f0\b MarkovSet
\f1\b0  and 
\f0\b MarkovSetN
\f1\b0  it can only read data as a chain, not as single nodes. \
Also it does not compress data, as the standard implementation does.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\i\b0\fs24 \cf0 instance creation:
\f1\i0 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 	*new(size)\
	*fill(size, stream)\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\i \cf0 instance methods:
\f0\i0\b \
	\
	next(obj, order)\
		
\f1\b0 return the next node for the input obj, using nth order (default = 1)\
		
\f0\b \
	put(index, obj)\
		
\f1\b0 put object in the data at index i\
		
\f0\b \
	wrapPut(index, obj)\
		
\f1\b0 wrapPut object in the data at index i\
		
\f0\b \
	parse(stream, length)\
		
\f1\b0 read 
\f2\i length
\f1\i0  items of stream\
		
\f0\b \
	asStream(order, repeats)\
		
\f1\b0 return a stream that reads from this set.\
		
\f0\b order
\f1\b0  can be any object that returns a stream on .asStream, returning integers.
\f0\b \
\
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\i \cf0 setting the data
\f4\i0\b0\fs18 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 \
m = \cf3 ShannonFinger\cf2 (16); \cf4 // create a new instance with 16 slots.\cf2 \
\
\cf5 "abc"\cf2 .do \{ \cf3 |item,i|\cf2  m.put(i, item) \}; \cf4 // fill the first 3 slots\cf2 \
\
m.data; \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf5 "abcdefghij"\cf2 .do \{ \cf3 |item,i|\cf2  m.put(i, item) \}; \cf4 // fill all 10 slots\cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 m.data; \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 \
\cf4 // fill the set directly:\cf2 \
\
m.data = \cf5 "abcdefghij"\cf2 ;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 // setting higher indices throws an error:\cf2 \
\
m.put(20, $x);\
\
\cf4 // wrapPut:\cf2 \
\
m.wrapPut(20, $x);\
m.data;\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\i\b\fs24 \cf0 using the set with the message 'next'
\f4\i0\b0\fs18 \cf2 \
\
\
m.next($a); \cf4 // returns b.\
m.next($c); // returns d\
\
// now put a "c" at index 8:\cf2 \
\
m.put(8, $c);\
m.data;\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 \
\cf4 // generate some output on basis of c:\cf2 \
\
10.do \{ m.next($c).postln \}; \cf4 // returns sometimes j and d\cf0 \
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\i\b\fs24 \cf0 generating a stream:
\f4\i0\b0\fs18 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 \
\
\cf4 //todo: fix this!!!\
\cf2 \
\cf4 // crete a new, independent stream from m:\cf2 \
x = m.asStream;\
60.do \{ x.next.post; \cf3 Char\cf2 .tab.post \}\
\
\cf4 // whenever there is no next (at the last index), a random index is chosen\cf2 \
\cf4 // to notify of this, set notify to true:\cf2 \
\
m.notify = \cf3 true\cf2 ;\
\
\
\cf0 \
\cf6 // minimal test:\cf0 \
m.data = (0..20);\
m.next(2);\
m.next(3);\
m.data\
m.lookUp;\
\
\
x = m.asStream;\
60.do \{ x.next.post; \cf7 Char\cf0 .tab.post \}\
\
\cf6 // minimal test:\cf0 \
m.data = \cf8 "abcdefghij"\cf0 ;\
m.next($a);\
m.next($i);\
m.data\
m.lookUp;\
m.put(0, $x);\
\
x = m.asStream;\
60.do \{ x.next.post; \cf7 Char\cf0 .tab.post \}\
\
\
\
\cf6 // with stream\cf0 \
\
m = \cf7 ShannonFinger\cf0 .fill(30, \cf7 Pseq\cf0 ([1, 2, \cf7 Prand\cf0 ([3, 7])],\cf7 inf\cf0 ).asStream);\
m.data\
m.lookUp;\
x = m.asStream;\
60.do \{ x.next.post; \cf7 Char\cf0 .tab.post \}\
\
\cf7 SynthDescLib\cf0 .read;\
\
\cf6 // listen to the set\cf0 \
(\
\cf7 Pbind\cf0 (\
	\cf9 \\degree\cf0 , \cf7 Pn\cf0 (x),\
	\cf9 \\dur\cf0 , 0.25\
).play;\
)\
\
\cf6 // change the data slowly\cf0 \
\
m.parse(\cf7 Pseq\cf0 ([1, 2, \cf7 Prand\cf0 ([6, 9], 2)], \cf7 inf\cf0 ), 20);\
m.parse(\cf7 Pseq\cf0 ([1, 5], \cf7 inf\cf0 ), 20);\
m.parse(\cf7 Pseq\cf0 ([5, 0, -2], \cf7 inf\cf0 ), 20);\
m.data = [3, 4, 5, 4, 5, 6];\
m.data\
\
\
\
\
\
}